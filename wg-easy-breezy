#!/bin/bash
#
# https://github.com/jinndi/wg-easy-breezy
#
# Copyright (c) 2025 Jinndi <alncores@gmail.ru>
#
# Released under the MIT License, see the accompanying file LICENSE
# or https://opensource.org/licenses/MIT

## Неинтерактивный режим установки APT
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

## Пути исполняемых файлов
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

## Пути файлов:
# - папка в которую будет произведена установка
path_data_dir="/opt/wg-easy-breezy"
# - файл текущего скрипта
path_script="$path_data_dir/wg-easy-breezy"
# - ссылка на файл текущего скрипта
path_script_link="/usr/bin/wgeb"
# - файл docker compose (podman-compose) настройки сервисов
path_docker_compose_file="$path_data_dir/services.yml"
# - файл переменных окружения .env
path_env_file="$path_data_dir/.env"
# - ссылка на файл systemd unit службы
path_systemd_unit_file="/etc/systemd/system/wg-easy-breezy.service"
# - файл настройки Caddy сервера
path_caddyfile="$path_data_dir/Caddyfile"
# - файл скрипта c сетевыми правилами iptables на запуск wg-easy-breezy
path_iptables_apply_script="$path_data_dir/iptables/apply.sh"
# - файл скрипта для удаления ранее созданных iptables правил
path_iptables_delete_script="$path_data_dir/iptables/delete.sh"
# - расположение файла конфига sysctl параметров
path_sysctl_config="$path_data_dir/sysctl.conf"
# - ссылка на файл конфига sysctl (path_sysctl_config)
path_sysctl_config_link="/etc/sysctl.d/99-wg-easy-breezy.conf"

# Ссылка на образ wg-easy
wg_easy_image="ghcr.io/jinndi/wg-easy-breezy:latest"

# Ссылка на образ caddy сервера
caddy_image="docker.io/library/caddy:2.10-alpine"

# Префикс к именам podman сервисов, сети, томов, url веб-интерфейсов
service_prefix="wgeb"

## Объявление переменных задаваемых в процессе работы скрипта:
# - ярлык имени службы, сети, томов, url веб-интерфейсов
service_tag=""
# - доменное имя либо IP-адрес хоста
host=""
# - e-mail адрес необходимый для получения SSL сертификата домена
email=""
# - ссылка (SIP002 URI scheme) для подключения к shadowsocks серверу
ss_link=""
# - tcp порт доступа к UI интерфейсу wg-easy
port_ui=""
# - udp порт WireGuard
port_wg=""
# - диапазон IP-адресов клиентов WireGuard
address=""
# - ссылка на UI интерфейс wg-easy
link_ui=""
# - указал ли пользователя адрес домена
is_domain=""
# - режим установки
# -- main - wg-easy базовый
# -- proxy - wg-easy -> прокси shasowsocks
install_mode=""

## Функции вывода сообщений:
# - шапка установщика
show_header() {
echo -e "\033[1;35m"
cat <<EOF
 ###################################################
 #                  WG-EASY-BREEZY                 #
 # GitHub:https://github.com/jinndi/wg-easy-breezy #
 ###################################################
EOF
echo -e "\033[0m"
}
# - стандартное
echomsg() {
  if [ -n "$2" ]; then
    echo
  fi
  echo -e "\033[1;34m $1 \033[0m"
}
# - об успехе
echook() {
  echo -e "\033[1;32m $1 \033[0m"
}
# - об ошибке
echoerr () {
  echo -e "\033[1;31m $1 \033[0m"
}
# - об ошибке с выходом из скрипта
exiterr() {
  echo -e "\033[1;31m Ошибка: $1\033[0m" >&2
  exit 1
}


## Функции проверок возможности установки:
# - рут права
check_root() {
  if [ "$(id -u)" != 0 ]; then
    exiterr "Этот установщик должен быть запущен от имени root. Попробуйте 'sudo bash $0'"
  fi
}

# - способ запуска скрипта через bash а не sh
check_shell() {
  if readlink /proc/$$/exe | grep -q "dash"; then
    exiterr 'Этот установщик необходимо запускать с помощью «bash», а не «sh».'
  fi
}

# - вид дистрибутива ОС
check_os() {
  if grep -qs "ubuntu" /etc/os-release; then
    os="ubuntu"
    os_version=$(grep 'VERSION_ID' /etc/os-release | cut -d '"' -f 2 | tr -d '.')
  elif [[ -e /etc/debian_version ]]; then
    os="debian"
    os_version=$(grep -oE '[0-9]+' /etc/debian_version | head -1)
  else
    exiterr "Этот установщик поддерживает только дистрибутивы Ubuntu и Debian!"
  fi
}

# - версия дистрибутива ОС
check_os_ver() {
  if [[ "$os" == "ubuntu" && "$os_version" -lt 2404 ]]; then
    exiterr "Для использования этого установщика требуется Ubuntu 24.04 или более поздняя версия."
  fi
  if [[ "$os" == "debian" && "$os_version" -lt 12 ]]; then
    exiterr "Для использования этого установщика требуется Debian 12 или более поздняя версия."
  fi
}

# - поддержка версии ядра
check_kernel() {
  if [[ $(uname -r | cut -d "." -f 1) -lt 6 ]]; then
     exiterr "Для установки необходимо ядро ОС версии >=6"
  fi
}

# - среда работы ОС (запрет установки из контейнера, например докер)
check_container() {
  if systemd-detect-virt -cq 2>/dev/null; then
    exiterr "Установка внути контейнера не поддерживается данным установщиком."
  fi
}
    
# Функция удаления предыдущих установок (без докера)
remove_install() {
  local is_show_info
  is_show_info="$1"

  if [[ -n "$is_show_info" ]]; then
    echomsg "Удаляем программу" 1
  fi

  # Остановка сервисов
  systemctl disable --now wg-easy-breezy > /dev/null 2>&1
  if [[ -e "$path_docker_compose_file" ]]; then
    podman-compose -f $path_docker_compose_file down -t 5 > /dev/null 2>&1
  fi

  # Удаление образов
  podman rmi "$wg_easy_image" > /dev/null 2>&1
  podman rmi "$caddy_image" > /dev/null 2>&1

  # Деактивация ранее заданных iptables правил 
  if [[ -f "$path_iptables_delete_script" ]]; then
    bash "$path_iptables_delete_script" > /dev/null 2>&1
  fi

  # Удаление ссылки на скрипт управления
  if [[ -L "$path_script_link" ]]; then
    rm -f "$path_script_link"
  fi

  # Удаление ссылки на sysctl конфиг с применением изменений
  if [[ -L "$path_sysctl_config_link" ]]; then
    rm -f "$path_sysctl_config_link"
    sysctl --system > /dev/null 2>&1
  fi
  
  # Удаление папки данных
  if [[ -d "$path_data_dir" ]]; then
    rm -rf "$path_data_dir"
  fi

  # Удаление файла systemd службы
  if [[ -f "$path_systemd_unit_file" ]]; then
    rm -f "$path_systemd_unit_file"
    systemctl daemon-reload
  fi

  if [[ -n "$is_show_info" ]]; then
    echook "Файлы и службы/сервисы удалены"
  fi
}

# Функция анимации ожидания
show_spinner() {
  local pid=$1
  local delay=0.1
  local spinner="|/-\\"
  tput civis  # скрыть курсор

  while kill -0 "$pid" 2>/dev/null; do
    for i in $(seq 0 3); do
      printf "\r [%c] Выполняем, ожидайте..." "${spinner:$i:1}"
      sleep "$delay"
    done
  done

  wait "$pid"
  local status=$?
  tput cnorm  # вернуть курсор
  echo
  return $status
}


# Функция установки необходимых пакетов программ
install_pkgs() {
  # ожидания пока система освободит блокировку пакетного менеджера (apt/dpkg)
  local count apt_lk apt_lk frontend_lk has_fuser has_lsof yq_path
  count=0
  apt_lk="/var/lib/apt/lists/lock"
  pkg_lk="/var/lib/dpkg/lock"
  frontend_lk="/var/lib/dpkg/lock-frontend"
  has_fuser=$(command -v fuser)
  has_lsof=$(command -v lsof)

  while \
    { [ "$has_fuser" ] && { fuser "$apt_lk" "$pkg_lk" "$frontend_lk" >/dev/null 2>&1; }; } || \
    { [ "$has_lsof" ] && { lsof "$apt_lk" >/dev/null 2>&1 || lsof "$pkg_lk" >/dev/null 2>&1 || \
    lsof "$frontend_lk" >/dev/null 2>&1; }; }
  do
    [ "$count" = 0 ] && echomsg "Ожидаем, когда apt освободится..."
    [ "$count" -ge 100 ] && exiterr "Не удалось дождаться разблокировку apt/dpkg."
    count=$((count+1))
    printf '%s' '.'
    sleep 3
  done

  echomsg "Обновление пакетов и установка зависимостей" 1
  (
    (
      apt-get -yqq update > /dev/null 2>&1 || apt-get -yqq update > /dev/null 2>&1
    ) || exiterr "'apt-get update' ошибка."
    (
      apt-get -yqq upgrade > /dev/null 2>&1 || apt-get -yqq upgrade > /dev/null 2>&1
    ) || exiterr "'apt-get upgrade' ошибка."
    (
      apt-get -yqq install podman podman-compose netavark aardvark-dns iproute2 iptables \
        openssl lsof dnsutils curl idn grep sed nano htop > /dev/null 2>&1 \
      || apt-get -yqq install podman podman-compose netavark aardvark-dns iproute2 iptables \
        openssl lsof dnsutils curl idn grep sed nano htop > /dev/null 2>&1
    ) || exiterr "'apt-get install' ошибка."

    # mikefarah yq
    yq_path=$(command -v yq)
    if [[ -n "$yq_path" ]]; then
      if ! yq --version 2>/dev/null | grep -q 'mikefarah'; then
        rm -f "$yq_path"
        hash -r 2>/dev/null
      fi
    fi
    if ! command -v yq >/dev/null; then
      curl -fsSL -H "Cache-Control: no-cache" -H "Pragma: no-cache" \
        https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 \
        -o /usr/local/bin/yq || {
        exiterr "Не удалось загрузить mikefarah/yq"
      }
      chmod +x /usr/local/bin/yq
    fi

    # конфиг podman containers, изменение сетевого бэкэнда на netavark
    # https://docs.oracle.com/en/operating-systems/oracle-linux/podman/podman-ConfiguringNetworkingforPodman.html#topic_owf_d4t_t5b
    mkdir -p /etc/containers/
    if [[ ! -f /etc/containers/containers.conf ]] && [[ -f /usr/share/containers/containers.conf ]]; then
      cp /usr/share/containers/containers.conf /etc/containers/
    else
      touch /etc/containers/containers.conf
    fi
    if grep -q 'network_backend' /etc/containers/containers.conf; then
      sed -i "/network_backend/c$(printf '%s\n' 'network_backend = "netavark"')" /etc/containers/containers.conf
    else
      if grep -q '^\[network\]' /etc/containers/containers.conf; then
        sed -i '/^\[network\]/a network_backend = "netavark"' /etc/containers/containers.conf
      else
        {
          echo ''
          echo '[network]'
          echo 'network_backend = "netavark"'
        } >> /etc/containers/containers.conf
      fi
    fi

    # Спуллить образ wg-easy
    podman pull "$wg_easy_image" > /dev/null 2>&1 || exiterr "ошибка при скачивании $wg_easy_image"

  ) & show_spinner $!

  echook "Пакеты обновлены, зависимости установлены"
}


## Фунции проверок введенных данных пользователем:

# - тег
check_tag() {
  local tag="$1"
  local service_name="${service_prefix}-${tag}"

  # Если строка не содержит только латиницу, цифры, тире (-)
  if [[ ! "$tag" =~ ^[A-Za-z0-9-]{1,16}$ ]]; then
    echoerr "Ошибка: '$tag' не соответствует требованиям"
    return 1
  fi

  if [[ -f "$path_docker_compose_file" ]] && \
    [[ "$(yq e ".services.\"$service_name\"" "$path_docker_compose_file")" != "null" ]]
  then
    echoerr "Ошибка: Сервис под тегом '$tag' уже существует"
    return 1
  fi

  return 0
}

# - имя домена
check_domain() {
  # Если строка не является доменом
  if [[ ! "$1" =~ ^([a-z0-9]([a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$ ]]; then
    echoerr "Неккоректный адрес домена: $1"
    is_domain=""
    return 1
  fi
  is_domain="true"
  return 0
}

# - IPv4 адрес
check_IPv4() {
  # Проверка на формат IPv4
  if [[ ! "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
    echoerr "Неверный формат IPv4: $1"
    return 1
  fi

  # Проверка на диапазон для каждого октета IP
  IFS='.' read -r -a octets <<< "$1"
  for octet in "${octets[@]}"; do
    # Проверка на ведущие нули (например, 01, 001)
    if [[ "$octet" != "0" && "$octet" =~ ^0 ]]; then
      echoerr "Октет IPv4 с ведущим нулём недопустим: $octet"
      return 1
    fi

    # Преобразуем явно в десятичное значение и проверим диапазон
    dec_octet=$((10#$octet))
    if ((dec_octet < 0 || dec_octet > 255)); then
      echoerr "Неверный диапазон октета IPv4: $octet"
      return 1
    fi
  done

  return 0
}

# - e-mail адрес
check_email() {
  # Если строка не является доменом
  if [[ ! "$1" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
    echoerr "Некорректный email: $1"
    return 1
  fi

  return 0
}

# - пароль
check_password() {
  # Проверка на пустой ввод
  if [ -z "$1" ]; then
    echoerr "Пароль не может быть пустым"
    return 1
  fi

  # Проверка длины пароля (минимум 6 символов)
  if [ "${#1}" -lt 6 ]; then
    echoerr "Пароль должен быть не короче 6 символов"
    return 1
  fi

  # Проверка наличия хотя бы одной буквы
  if ! echo "$1" | grep -q '[a-zA-Z]'; then
    echoerr "Пароль должен содержать хотя бы одну букву"
    return 1
  fi

  # Проверка наличия хотя бы одной цифры
  if ! echo "$1" | grep -q '[0-9]'; then
    echoerr "Пароль должен содержать хотя бы одну цифру"
    return 1
  fi

  return 0
}

# - порт
check_port() {
  local port="$1"

  # Проверка, является ли порт числом
  if ! [[ "$port" =~ ^[0-9]+$ ]]; then
    echoerr "Порт должен быть числом"
    return 1
  fi

  # Проверка диапазона порта (49152–65534)
  if [ "$port" -lt 49152 ] || [ "$port" -gt 65534 ]; then
    echoerr "Порт должен быть в диапазоне от 49152 до 65534"
    return 1
  fi

  # Проверка, занят ли порт в данный момент
  if lsof -i :"$port" >/dev/null ; then
    echoerr "Порт '$port' занят"
    return 1
  fi

  # Проверка не записан ли порт уже в services.yml
  if [[ -f "$path_docker_compose_file" ]]; then
    yq -r '.services | keys[]' "$path_docker_compose_file" | while read -r service; do
      if [[ "$service" == "${service_prefix}-"* ]]; then
        local port_wg port_ui
        port_wg=$(get_env_var_from_service "$service" "WG_PORT" "")
        port_ui=$(get_env_var_from_service "$service" "PORT" "")
        if [[ "$port" == "$port_wg" ]] || [[ "$port" == "$port_ui" ]]; then
          echoerr "Порт '$port' уже назначен в сервисе $service"
          return 1
        fi
      fi
    done
  fi

  return 0
}

# Функция получени IP сервера
get_public_ip() {
  local public_ip

  # ip route (локальный интерфейс)
  public_ip=$(ip route get 1.1.1.1 2>/dev/null | awk '{for(i=1;i<=NF;i++) if ($i=="src") print $(i+1)}')

  # через dig
  [ -z "$public_ip" ] && command -v dig >/dev/null && \
    public_ip=$(dig +short -4 myip.opendns.com @resolver1.opendns.com)

  # Через curl
  [ -z "$public_ip" ] && command -v curl >/dev/null && \
    public_ip=$(curl -s https://api.ipify.org)

  # Проверка
  if ! check_IPv4 "$public_ip"; then
    echoerr "Не удалось определить публичный IP"

    while true; do
      echomsg "Введите публичный IPv4 адрес этого сервера"
      read -rp "IPv4 этого сервера: " public_ip
      if check_IPv4 "$public_ip"; then break; fi
    done
  fi

  echo "$public_ip"
}


## Функции ввода:

# - ярлык для добавляемой службы (полное имя service_prefix-service_tag)
input_tag() {
  while true; do
    echomsg "Которкое обозначение (tag). Латиница, цифры и тире до 16 символов." 1
    echomsg "(используется для добавления к имени контейнера, сети, томов, URL веб-интерфейса)"
    read -rp " > " service_tag
    
    if check_tag "$service_tag"; then
      echook "Тег: $service_tag принят"
      break
    fi
  done
}

# - имя домена (либо IPv4 если нет)
input_domain() {
  while true; do
    echomsg "Доменное имя этого сервера, например mydomain.com" 1
    echomsg "(нажмите клавишу Enter чтобы задать позже)"
    read -rp " > " host
    
    # Проверка на пустой ввод
    if [ -z "$host" ]; then
      host=$(get_public_ip)
      echook "Используем IPv4: $host"
      break
    else
      # преобразуем в punycode (на случай кириллицы) с нижним регистром
      host=$(idn "$host" | tr '[:upper:]' '[:lower:]')
      # проверка имени
      if check_domain "$host"; then
        echook "Доменное имя: $host принято"
        break
      fi
    fi
  done

  # заменяем/добавляем значение в .env
  if grep -q '^WG_HOST=' "$path_env_file"; then
    sed -i "s/^WG_HOST=.*/WG_HOST=$host/" "$path_env_file"
  else
    echo "WG_HOST=$host" >> "$path_env_file"
  fi
}

# - e-mail для полученя SSL сертификата домена
input_email() {
  [[ "$is_domain" ]] || return

  while true; do
    echomsg "Ваш e-mail для получения SSL сертификата" 1
    read -rp " > " email

    # Проверка ввода
    if check_email "$email"; then
      echook "E-mail: $email принят"
      break
    fi
  done
}

# - ссылка на подключение к shadowsocks (SIP002 URI scheme)
input_ss_link() {
  [[ "$install_mode" = "main" ]] && return

  local ss_clean base64_part ip_port_part public_ip port decoded password method

  while true; do
    echomsg "Ссылка подключения к shadowsocks" 1
    read -rp " > " ss_link
    
    # Проверка на пустой ввод
    if [ -z "$ss_link" ]; then
      break
    fi

    # Добавляем префикс ss://, если его нет
    [[ "$ss_link" != ss://* ]] && ss_link="ss://${ss_link}"

    # Удаляем префикс
    ss_clean="${ss_link#ss://}"

    # Извлекаем base64, IP и порт
    base64_part="${ss_clean%@*}"
    ip_port_part="${ss_clean#*@}"
    public_ip="${ip_port_part%%:*}"
    port="${ip_port_part##*:}"

    # Декодируем base64 строку
    if ! decoded=$(echo "$base64_part" | openssl base64 -d 2>/dev/null); then
      echoerr "Ошибка: base64 не удалось декодировать"
      continue
    fi

    # Получаем и проверяем метод шифра 
    method="${decoded%%:*}"
    case "$method" in
      chacha20-ietf-poly1305|aes-128-gcm|aes-256-gcm)
        # Всё ок
        ;;
      *)
        echoerr "Ошибка: недопустимый метод шифрования: $method"
        continue
        ;;
    esac

    # Проверка IPv4
    if check_IPv4 "$public_ip"; then
      # Проверка порта
      if ! [[ "$port" =~ ^[0-9]+$ ]] || (( port < 49152 || port > 65535 )); then
        echoerr "Ошибка: порт $port вне диапазона 49152–65535"
        continue
      fi

      echook "Ссылка shadowsocks принята"
      break
    fi
  done
}

# - порт WireGuard сервера, и UI интерфейса
input_port() {
  while true; do
    echomsg "Порт для WireGuard от 49152 до 65534" 1
    echomsg "(для веб интерфейса будет увеличен на 1)"
    read -rp " > " port_wg

    # Увеличиваем порт на 1 (для UI интерфейса)
    port_ui=$((port_wg + 1))

    # Проверка портов
    if check_port "$port_wg" && check_port "$port_ui"; then
      echook "Заданы порты:"
      echook " - WireGuard: $port_wg"
      echook " - Веб интерфейс: $port_ui"
      break
    fi
  done
}

# - диапазон адресов для клиентов WireGuard
input_address() {
  local default_value="10.0.0.x"

  while true; do
    echomsg "Диапазон IP адресов клиентов WireGuard," 1
    echomsg "например 10.0.0.x, 10.1.0.x, и т.п."
    read -r -e -i " $default_value" address
    address=${address:-$default_value}

    # Проверка на конфликты
    if [[ -f "$path_docker_compose_file" ]]; then
      local conflict=0
      while read -r service; do
        if [[ "$service" == "${service_prefix}-"* ]]; then
          local existing_address
          existing_address=$(get_env_var_from_service "$service" "WG_DEFAULT_ADDRESS" "")
          if [[ "$address" == "$existing_address" ]]; then
            echoerr "Значение '$address' уже назначено в сервисе $service"
            conflict=1
            break
          fi
        fi
      done < <(yq -r '.services | keys[]' "$path_docker_compose_file")

      if [[ "$address" == "192.168.100.x" ]]; then
        echoerr "Значение '$address' используется сетью контейнеров"
        conflict=1
      fi

      if [[ "$conflict" -eq 1 ]]; then
        continue  # вернуться к началу ввода
      fi
    fi

    break  # адрес уникален
  done

  echook "Задан диапазон адресов для клиентов: $address"
}


# - пароль для входа в UI wg-easy
input_password() {
  local output_wgpw password password_hash

  while true; do
    echomsg "Сложный пароль для входа в веб-интерфейс(ы) (ввод скрыт)," 1
    echomsg "шесть и более символов, обязательно наличие буквы и цифры"
    read -rsp " > " password
    
    # Проверка и обработка пароля
    if check_password "$password"; then
      # Запрашиваем хеша пароля
      output_wgpw=$(podman run --rm -it $wg_easy_image wgpw "$password")
      # Извлекаем и экранируем хеш пароля
      password_hash=$(echo "$output_wgpw" | tr -d '\r\n')
      if grep -q '^PASSWORD_HASH=' "$path_env_file"; then
        sed -i "s|^PASSWORD_HASH=.*|$password_hash|" "$path_env_file"
      else
        echo "$password_hash" >> "$path_env_file"
      fi
      echo
      echook "Пароль веб интерфейса установлен"
      break
    fi
  done
}

# Функция поиска оптимального MTU WireGuard
find_optimal_wg_mtu() {
  local target=8.8.8.8
  local low=1300
  local high=1500
  local last_good=0
  local wg_mtu

  echomsg "Поиск оптимального MTU для WireGuard..." 1

  while (( low <= high )); do
    local mid=$(((low + high) / 2))
    local size=$((mid - 28))  # 20 байт IP + 8 байт ICMP

    if ping -c1 -W1 -M "do" -s "$size" "$target" &>/dev/null; then
      last_good=$mid
      low=$((mid + 1))
    else
      high=$((mid - 1))
    fi
  done

  if [ "$last_good" -ge 1000 ] 2>/dev/null; then
    # Рассчитываем MTU для WireGuard
    wg_mtu=$((last_good - 80))
    (( wg_mtu < 1200 )) && wg_mtu=1200

    echook "Оптимальный MTU WireGuard: $wg_mtu"
  else
    wg_mtu=1420
    echoerr "Значение не найдено, используем: 1420"
  fi
  echo "WG_MTU=$wg_mtu" >> $path_env_file 
}

# Функция получени пути iptables
get_iptables_path() {
  local path
  path=$(command -v iptables)

  if [[ $(systemd-detect-virt) == "openvz" ]] && \
     readlink -f "$path" | grep -q "nft" && \
     hash iptables-legacy 2>/dev/null; then
    path=$(command -v iptables-legacy)
  fi

  echo "$path"
}

# Функция добавления правил в apply и delete скрипты iptables по port и proto
add_iptables_rule() {
  local port="$1"
  local proto="$2"
  local iptables_path
  iptables_path="$(get_iptables_path)"
  local apply_rule="$iptables_path -w 5 -I INPUT -p $proto --dport $port -j ACCEPT"
  local delete_rule="$iptables_path -w 5 -D INPUT -p $proto --dport $port -j ACCEPT"

  grep -qxF "$apply_rule" "$path_iptables_apply_script" 2>/dev/null || \
    echo "$apply_rule" >> "$path_iptables_apply_script"
  grep -qxF "$delete_rule" "$path_iptables_delete_script" 2>/dev/null || \
    echo "$delete_rule" >> "$path_iptables_delete_script"
}

# Функция удаления правил из apply и delete скриптов iptables по port и proto  
remove_iptables_rule() {
  local port="$1"
  if [[ "$port" ]]; then
    sed -i "/\b$port\b/d" "$path_iptables_apply_script"
    sed -i "/\b$port\b/d" "$path_iptables_delete_script"
  fi
}

# Создание скриптов разрешения портов через iptables, при запуске/остановке службы
create_iptables_scripts() {
  echomsg "Создание скриптов разрешения портов через iptables" 1

  # Создать дирректорию для сохранения скриптов на запуск/остановку служб
  mkdir -p "$(dirname "$path_iptables_apply_script")"
  mkdir -p "$(dirname "$path_iptables_delete_script")"

  # Очистка/создание файлов перед формированием конфигов
  : > "$path_iptables_apply_script"
  : > "$path_iptables_delete_script"

  # Формируем скрипты с правилами:
  {
    echo "#!/bin/bash"
    echo ""
  } | tee "$path_iptables_apply_script" "$path_iptables_delete_script" > /dev/null

  # Запрет 80/tcp порта
  local iptables_path
  iptables_path="$(get_iptables_path)"
  echo "$iptables_path -w 5 -I INPUT -p tcp --dport 80 -j DROP" >> "$path_iptables_apply_script"
  echo "$iptables_path -w 5 -D INPUT -p tcp --dport 80 -j DROP" >> "$path_iptables_delete_script"

  # Делаем скрипты исполняемыми
  chmod +x "$path_iptables_apply_script" "$path_iptables_delete_script"

  echook "Скрипты с правилами iptables созданы"
}

# Функция загрузки переменных из .env (если он существует)
load_env() {
  if [ -f "$path_env_file" ]; then
    set -o allexport
    # shellcheck disable=SC1090
    source "$path_env_file"
    set +o allexport
  fi
}

# Функция добавления сервиса wg
add_wg_service() {
  local service_name="$service_prefix-$1"
  local port_wg="${2:-51820}"
  local port_ui="${3:-51821}"
  local address="${4:-10.8.1.x}"
  local ss_link="${5:-}"

  # добавление сервиса
  yq e -i ".services.${service_name} = {
    \"image\": \"${wg_easy_image}\",
    \"container_name\": \"${service_name}\",
    \"environment\": {
      \"LANG\": \"\${LANG}\",
      \"WG_HOST\": \"\${WG_HOST}\",
      \"PASSWORD_HASH\": \"\${PASSWORD_HASH}\",
      \"PORT\": \"${port_ui}\",
      \"WG_PORT\": \"${port_wg}\",
      \"WG_MTU\": \"\${WG_MTU}\",
      \"WG_PERSISTENT_KEEPALIVE\": \"\${WG_PERSISTENT_KEEPALIVE}\",
      \"WG_DEFAULT_ADDRESS\": \"${address}\",
      \"WG_DEFAULT_DNS\": \"\${WG_DEFAULT_DNS}\",
      \"UI_TRAFFIC_STATS\": \"\${UI_TRAFFIC_STATS}\"
    },
    \"volumes\": [
      \"${service_name}:/etc/wireguard\",
      \"/lib/modules:/lib/modules\"
    ],
    \"networks\": [\"${service_prefix}\"],
    \"ports\": [
      \"${port_wg}:${port_wg}/udp\",
      \"${port_ui}:${port_ui}/tcp\"
    ],
    \"privileged\": true,
    \"ulimits\": {
      \"nofile\": {
        \"soft\": 51200,
        \"hard\": 51200
      }
    }
  }" "$path_docker_compose_file"

  # если ss_link передана
  if [ -n "$ss_link" ]; then
    # добавить devices
    yq e -i "
      .services.${service_name}.devices = [\"/dev/net/tun\"]
    " "$path_docker_compose_file"

    # переменные в environment
    yq e -i ".services.${service_name}.environment += {
        \"WG_DEVICE\": \"sstun\",
        \"SS_TUN_NAME\": \"sstun\",
        \"SS_LINK\": \"${ss_link}\"
      }
    " "$path_docker_compose_file"
  fi

  # volumes как service_name
  yq e -i ".volumes += {
    \"${service_name}\": { \"name\": \"${service_name}\" }
  }" "$path_docker_compose_file"

  # правила iptables
  add_iptables_rule "$port_wg" "udp"
  add_iptables_rule "$port_ui" "tcp"

  # если файл caddyfile существует
  if [[ -f "$path_caddyfile" ]]; then
    # reverse_proxy в caddyfile 
    {
      echo "handle_path /$service_name/* {"
      echo "  reverse_proxy $service_name:$port_ui"
      echo "}"
    } >> "$path_caddyfile"
    # cсылка на UI интерфейс wg-easy
    link_ui="https://${WG_HOST}/${service_name}/"
  else
    link_ui="http://${WG_HOST}:${port_ui}"
  fi
}

# Функция добавления Caddy сервиса
add_caddy_service() {
  [[ "$is_domain" ]] || return

  # Спуллить образ
  podman pull "$caddy_image" > /dev/null 2>&1 || exiterr "ошибка при скачивании $caddy_image"
  
  local service_name="caddy-$service_prefix"

  # - services
  yq e -i ".services.${service_name} = {
    \"image\": \"${caddy_image}\",
    \"container_name\": \"${service_name}\",
    \"cap_add\": [\"NET_ADMIN\"],
    \"ports\": [
      \"443:443/tcp\",
      \"443:443/udp\"
    ],
    \"volumes\": [
      \"${path_caddyfile}:/etc/caddy/Caddyfile\",
      \"${service_name}-data:/data\",
      \"${service_name}-config:/config\"
    ],
    \"networks\": [\"${service_prefix}\"]
  }" "$path_docker_compose_file"

  # - volumes
  yq e -i ".volumes += {
    \"${service_name}-data\": { \"name\": \"${service_name}-data\" },
    \"${service_name}-config\": { \"name\": \"${service_name}-config\" }
  }" "$path_docker_compose_file"

  # - iptables
  add_iptables_rule "443" "udp"
  add_iptables_rule "443" "tcp"

  # - Caddyfile
  mkdir -p "$(dirname "$path_caddyfile")"
  {
    echo "$host"
    echo "tls $email"
  } > "$path_caddyfile"

  # - handle_path, если добавляем Caddy после установок wg
  yq -r '.services | keys[]' "$path_docker_compose_file" | while read -r service; do
    if [[ "$service" == "${service_prefix}-"* ]]; then
      local port_ui
      port_ui=$(get_env_var_from_service "$service" "PORT" "not_found")
      {
        echo "handle_path /$service/* {"
        echo "  reverse_proxy $service:$port_ui"
        echo "}"
      } >> "$path_caddyfile"
    fi
  done
}

# Функция создания wg сервиса в зависимости от выбранного режима установки
create_wg_install_mode() {
  case "$install_mode" in
    "main")
      add_wg_service "$service_tag" "$port_wg" "$port_ui" "$address"
    ;;
    "proxy")
      add_wg_service "$service_tag" "$port_wg" "$port_ui" "$address" "$ss_link"
    ;;
    *)
      exiterr "Неизвестный режим установки: $install_mode"
    ;;
  esac
}

# Функция создания конфигов сервисов и служб
create_services_config() {
  # Подгружаем .env
  load_env

  echomsg "Создаём и загружаем конфиги сервисов" 1

  # services.yml шаблон
  mkdir -p "$(dirname "$path_docker_compose_file")"
  echo -e "services: {}\nvolumes: {}\nnetworks: {}" > "$path_docker_compose_file"

  # cервис Caddy сервера (если указано доменное имя)
  [[ "$is_domain" ]] && add_caddy_service

  # cервис wg-easy-breezy в зависимости от выбранного режима установки
  create_wg_install_mode

  # networks
  yq e -i ".networks += {
    \"${service_prefix}\": {
      \"name\": \"${service_prefix}\",
      \"driver\": \"bridge\",
      \"ipam\": {
        \"config\": [
          {
            \"subnet\": \"192.168.100.0/24\",
            \"gateway\": \"192.168.100.1\"
          }
        ]
      }
    }
  }" "$path_docker_compose_file"

  echook "Конфиги сервисов загружены и созданы"
}

# Функция создания конфига sysctl настроек сети
create_sysctl_config () {
  echomsg "Создание конфига sysctl" 1

  # Создать дирректорию если нет
  mkdir -p "$(dirname "$path_sysctl_config")"
  mkdir -p "$(dirname "$path_sysctl_config_link")"
  
  # Загружаем конфиг
  curl -fsSL -H "Cache-Control: no-cache" -H "Pragma: no-cache" \
    https://raw.githubusercontent.com/jinndi/wg-easy-breezy/main/sysctl.conf \
    -o "$path_sysctl_config"

  # Проверка что файл загружен
  if [ -f "$path_sysctl_config" ]; then
    # Включение TCP BBR контроля перегрузки, если не удачно, то пробуем hybla
    if modprobe -q tcp_bbr && [ -f /proc/sys/net/ipv4/tcp_congestion_control ]
    then
      echo "net.core.default_qdisc = fq" >> "$path_sysctl_config"
      echo "net.ipv4.tcp_congestion_control = bbr" >> "$path_sysctl_config"
    else
      if modprobe -q tcp_hybla && [ -f /proc/sys/net/ipv4/tcp_congestion_control ]
      then
        echo "net.ipv4.tcp_congestion_control = hybla" >> "$path_sysctl_config"
      fi
    fi

    # Создаем ссылку на файл
    ln -s "$path_sysctl_config" "$path_sysctl_config_link"

    # Применяем полученный конфиг
    sysctl -e -q -p "$path_sysctl_config_link"
    
    echook "Конфиг sysctl создан и применен"
  else
    exiterr "Ошибка загрузки sysctl конфига"
  fi
}

# Функция создания systemd unit службы управления сервисами
create_systemd_unit() {
  local working_dir path_podman_compose
  working_dir="$(dirname "$path_docker_compose_file")"
  path_podman_compose=$(command -v podman-compose)

  echomsg "Создание systemd службы" 1
  {
    echo "[Unit]"
    echo "Description=wg-easy-breezy with iptables hooks via podman-compose"
    echo "After=network-online.target"
    echo "Wants=network-online.target"
    echo
    echo "[Service]"
    echo "Type=simple"
    echo "WorkingDirectory=$working_dir"
    echo "EnvironmentFile=$path_env_file"
    echo "ExecStartPre=$path_iptables_apply_script"
    echo "ExecStart=$path_podman_compose -f $path_docker_compose_file up --force-recreate --remove-orphans"
    echo "ExecStop=$path_podman_compose -f $path_docker_compose_file down --timeout 5"
    echo "ExecStopPost=$path_iptables_delete_script"
    echo "Restart=on-failure"
    echo "RestartSec=10"
    echo "LimitNOFILE=51200"
    echo
    echo "[Install]"
    echo "WantedBy=multi-user.target"
  } > "$path_systemd_unit_file"

  systemctl daemon-reexec
  systemctl daemon-reload

  echook "Служба создана"
}

# Функция проверки что все сервисы запущены и работают корректно
is_all_ok_services() {
  # если файл docker compose не существует — false
  if [[ ! -e "$path_docker_compose_file" ]]; then
    return 1
  fi

  # проверка что systemd служба активна 
  if ! systemctl is-active --quiet wg-easy-breezy; then
    return 1
  fi

  return 0
}

# Фукнция ожидания запуска всех контейнеров (до 90 сек)
wait_for_containers() {
  sleep 5
  mapfile -t services < <(yq -r '.services | keys[]' "$path_docker_compose_file")

  local failed=0

  for service in "${services[@]}"; do
    local elapsed=0
    local status=""
    while true; do
      status=$(podman inspect -f '{{.State.Status}}' "$service" 2>/dev/null || echo "notfound")

      if [[ "$status" == "running" ]]; then
        break
      elif [[ "$status" == "exited" || "$status" == "stopped" || "$status" == "notfound" ]]; then
        failed=1
        break
      fi

      sleep 1
      ((elapsed++))
      if (( elapsed >= 85 )); then
        failed=1
        break
      fi
    done
  done

  if (( failed == 1 )); then
    echoerr "\n Некоторые контейнеры не запустились, либо время ожидания истекло!\n"
    return 1
  fi

  echook "\n Все контейнеры запущены и работают!\n"
  return 0
}

# Функция запуска всех сервисов
start_services() {
  echomsg "Запускаем сервисы" 1

  # Запускаем докер контейнеры
  systemctl enable --now wg-easy-breezy > /dev/null 2>&1
  wait_for_containers
  if ! systemctl is-active --quiet wg-easy-breezy; then
    echoerr "Запуск не удался"
  else
    echook "Служба успешно запущена!"
  fi
}

# Функция остановки всех сервисов и служб
stop_services() {
  echomsg "Останавливаем сервисы" 1

  # Останавливаем и удаляем docker-контейнеры
  if [[ -f "$path_docker_compose_file" ]]; then
    systemctl disable --now wg-easy-breezy > /dev/null 2>&1
    if systemctl is-active --quiet wg-easy-breezy; then
      echoerr "Остановка не удалась"
    else
      echook "Служба успешно остановлена!"
    fi
  else
    echoerr "Файл docker-compose не найден: $path_docker_compose_file"
  fi
}

# Функция переключения статуса активности сервисов
switch_active_services() {
  # Если все сервисы и службы работают
  if is_all_ok_services; then
    stop_services
  else
    start_services
  fi

  press_any_side_to_open_menu
}

# Функция перезапуска  сервисов
restart_services() {
  echomsg "Перезапускаем сервисы" 1
  systemctl stop wg-easy-breezy > /dev/null 2>&1
  systemctl start wg-easy-breezy > /dev/null 2>&1
  wait_for_containers
  if is_all_ok_services; then
    echook "Служба успешно перезапущена!"
  else
    echoerr "Ошибка перезапуска! Введите 'journalctl -u wg-easy-breezy -n 30' для просмотра лога"
  fi

  press_any_side_to_open_menu
}

# Функция извлечения переменной из environment по имени сервиса 
get_env_var_from_service() {
  local service="$1"
  local var_name="$2"
  local default_value="${3:-}"

  yq -r ".services.\"$service\".environment.\"$var_name\" // \"$default_value\"" "$path_docker_compose_file"
}

# Функция вывода списка служб на основе compose yml файла
show_services_list() {
  local service container_status ports status ss_link port_ui address
  local output=""

  mapfile -t services < <(yq -r '.services | keys[]' "$path_docker_compose_file")

  for service in "${services[@]}"; do
    container_status=$(podman ps -a --filter "name=${service}" --format "{{.Names}} {{.Status}}" | head -n1)

    if [[ -z "$container_status" ]]; then
      status="\033[1;34mне запущен\033[0m"
    elif [[ "$container_status" == ${service}* ]]; then
      if [[ "$container_status" =~ Up ]]; then
        status="\033[1;32mработает\033[0m"
      else
        status="\033[1;31mне работает\033[0m"
      fi
    else
      status="неизвестный"
    fi

    ports=$(yq -r ".services.\"$service\".ports // [] | join(\", \")" "$path_docker_compose_file")
    [[ -z "$ports" ]] && ports="—"

    output+=$'\n'
    output+="\033[0;36m Имя сервиса:\033[0m $service\n"
    output+="\033[0;36m Статус:\033[0m $status\n"
    output+="\033[0;36m Проброс портов:\033[0m $ports\n"

    if [[ "$service" == "${service_prefix}-"* ]]; then
      ss_link=$(get_env_var_from_service "$service" "SS_LINK" "")
      port_ui=$(get_env_var_from_service "$service" "PORT" "-")
      address=$(get_env_var_from_service "$service" "WG_DEFAULT_ADDRESS" "-")

      if [[ -n "$ss_link" ]]; then
        output+="\033[0;36m Прокси режим:\033[0m да, shadowsocks -> ${ss_link#*@}\n"
      else
        output+="\033[0;36m Прокси режим:\033[0m нет\n"
      fi

      output+="\033[0;36m Адреса клиентов wg:\033[0m $address\n"

      if [[ -f "$path_caddyfile" ]]; then
        output+="\033[0;36m Веб интерфейс:\033[0m https://${WG_HOST}/${service}/\n"
      else
        output+="\033[0;36m Веб интерфейс:\033[0m http://${WG_HOST}:${port_ui}\n"
      fi
    fi

    output+=" ___________________________________________________\n"
  done

  # Выводим всё разом
  echo -e "$output"
}

# Функция добавления нового сервиса wg-easy
add_new_wg_service() {
  # выбор режима установки
  select_install_mode 1

  # считывание вода пользователя
  input_tag
  input_ss_link
  input_port
  input_address

  # останавливаем службу
  systemctl stop wg-easy-breezy > /dev/null 2>&1

  # добавляем wg сервис в зависимости от выбранного режима установки
  create_wg_install_mode

  # запускаем службу
  systemctl start wg-easy-breezy > /dev/null 2>&1
  wait_for_containers

  echo -e "\n\033[1;32m 🎉 wg-easy добавлен! \033[0m"
  echo -e "\033[0;36m Веб интерфейс: \033[1;32m$link_ui \033[0m\n"

  press_any_side_to_open_menu "containers"
}

# Функция удаления сервиса wg-easy
remove_wg_service() {
  # ввод имени сервиса для удаления
  while true; do
    echo -e "\n Введите имя сервиса для удаления"
    echo -e " (Enter без ввода возвращает в меню)"
    read -rp " > " service_name

    if [[ -z "$service_name" ]]; then
      select_containers_menu
      return
    fi

    if [[ "$(yq e ".services.\"$service_name\"" "$path_docker_compose_file")" != "null" ]]; then
      echomsg "Удаляем сервис $service_name" 1
      break
    else
      echoerr "Сервис $service_name НЕ найден"
    fi
  done

  local port_wg port_ui

  # останавливаем службу
  systemctl stop wg-easy-breezy > /dev/null 2>&1

  # правила iptables
  port_wg=$(get_env_var_from_service "$service_name" "WG_PORT" "")
  port_ui=$(get_env_var_from_service "$service_name" "PORT" "")
  remove_iptables_rule "$port_wg"
  remove_iptables_rule "$port_ui"

  # services.yml записи services и volumes
  yq e -i "del(.services.${service_name})" "$path_docker_compose_file"
  yq e -i "del(.volumes.${service_name})" "$path_docker_compose_file"

  # volume том
  # podman volume rm "$service_name" > /dev/null 2>&1

  # реверс прокси в caddyfile
  if [[ -f "$path_caddyfile" ]]; then
    sed -i "/^[[:space:]]*handle_path[[:space:]]\+\\/$service_name\\/\\*/,/^[[:space:]]*}/d" "$path_caddyfile"
  fi

  # запускаем службу
  systemctl start wg-easy-breezy > /dev/null 2>&1
  wait_for_containers

  echook "🎈 Сервис $service_name удален!"
  press_any_side_to_open_menu "containers"
}

# Функция подтверждения удаления приложения
remove_services() {
  echo
  local msg
  msg=" Удалить приложение? [y/N]: "
  read -rp "$msg" remove

  until [[ "$remove" =~ ^[yYnNдДнН]$ ]]; do
    echoerr "Неверная опция"
    read -rp "$msg" remove
  done

  if [[ "$remove" =~ ^[yYдД]$ ]]; then
    remove_install "1"
    exit 0
  else
    select_menu_option
  fi
}

# Функция выбора режима установки
select_install_mode() {
  local is_menu="${1:-}"
  local total_items=2
  echo
  echo " Выберите режим установки"
  echo "  1) Стандартный wg-easy"
  echo "  2) Прокси wg-easy -> shadowsocks"
  if [[ -n "$is_menu" ]]; then
    echo "  3) Вернуться в меню"
    total_items=3
  fi

  read -rp " Выбор: " mode
  until [[ "$mode" =~ ^[1-$total_items]$ ]]; do
    echoerr "Неверная опция"
    read -rp " Выбор: " mode
  done

  case "$mode" in
    1)
      install_mode="main"
    ;;
    2)
      install_mode="proxy"
    ;;
    3)
      select_containers_menu
    ;;
  esac
}

# Функция добавления доменного имени
add_domain() {
  input_domain
  input_email
  if [[ "$is_domain" ]]; then
    # останавливаем службу
    systemctl stop wg-easy-breezy > /dev/null 2>&1

    # добавляем caddy сервер с настройкой реверспрокси
    add_caddy_service

    # поднимаем  службу
    systemctl start wg-easy-breezy > /dev/null 2>&1

    echook "🎉 Домен '$host' добавлен и активирован"
  fi
  select_domain_option
}

# Функция изменения доменного имени
change_domain() {
  host=""

  while true; do
    echomsg "Введите новое доменное имя" 1
    echoerr "После смены созданные ранее wg конфиги клиентов"
    echoerr "требуют замены либо изменения адреса пира."
    echomsg "(нажмите Enter с пустым вводом для отмены)"
    read -rp " > " host
    
    # Проверка на пустой ввод
    if [ -z "$host" ]; then
      break
    else
      # преобразуем в punycode (на случай кириллицы) с нижним регистром
      host=$(idn "$host" | tr '[:upper:]' '[:lower:]')
      # если прошли проверку
      if check_domain "$host"; then
        echomsg "Применяем доменное имя '$host'" 1

        # останавливаем службу
        systemctl stop wg-easy-breezy > /dev/null 2>&1

        # заменяем значение в .env
        if grep -q '^WG_HOST=' "$path_env_file"; then
          sed -i "s/^WG_HOST=.*/WG_HOST=$host/" "$path_env_file"
        else
          echo "WG_HOST=$host" >> "$path_env_file"
        fi

        # заменяем значение в Caddyfile
        if grep -q "$WG_HOST" "$path_caddyfile"; then
          sed -i "s/$WG_HOST/$host/" "$path_caddyfile"
        else
          sed -i "1i $host" "$path_caddyfile"
        fi

        # поднимаем  службу
        systemctl start wg-easy-breezy > /dev/null 2>&1

        echook "🎉 Домен '$WG_HOST' изменен на '$host'"
        break
      fi
    fi
  done

  select_domain_option
}

# Функция удаления доменного имени
remove_domain() {
  local msg
  echoerr "\nПосле удаления доменного имени,"
  echoerr "созданные ранее wg конфиги клиентов"
  echoerr "требуют замены либо изменения адреса пира."
  msg="Удаляем? [y/N]: "
  read -rp "$msg" remove

  until [[ "$remove" =~ ^[yYnNдДнН]$ ]]; do
    echoerr "Неверная опция"
    read -rp "$msg" remove
  done

  if [[ "$remove" =~ ^[yYдД]$ ]]; then
    local service_name="caddy-$service_prefix"

    echomsg "Удаляем доменное имя '$WG_HOST'" 1

    # останавливаем службу
    systemctl stop wg-easy-breezy > /dev/null 2>&1

    # services.yml записи services и volumes
    yq e -i "del(.services.${service_name})" "$path_docker_compose_file" > /dev/null 2>&1
    yq e -i "del(.volumes.${service_name}-data)" "$path_docker_compose_file" > /dev/null 2>&1
    yq e -i "del(.volumes.${service_name}-config)" "$path_docker_compose_file" > /dev/null 2>&1

    # правила iptables
    remove_iptables_rule "443"

    # caddyfile
    [[ -f "$path_caddyfile" ]] && rm "$path_caddyfile"

    # заменяем значение в .env
    host=$(get_public_ip)
    if grep -q '^WG_HOST=' "$path_env_file"; then
      sed -i "s/^WG_HOST=.*/WG_HOST=$host/" "$path_env_file"
    else
      echo "WG_HOST=$host" >> "$path_env_file"
    fi

    # запускаем службу
    systemctl start wg-easy-breezy > /dev/null 2>&1
    wait_for_containers

    echook "🎈 Доменное имя '$WG_HOST' удалено!"
  fi

  select_domain_option
}

# Функция управлени домменным именем
select_domain_option() {
  # грузим .env
  load_env

  show_header

  # определяем установлено ли доменное имя
  local is__domain=""
  [[ -f "$path_caddyfile" ]] &&  \
  [[ "$WG_HOST" =~ ^([a-z0-9]([a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$ ]] && \
  is__domain="true"

  echo
  if [[ "$is__domain" ]]; then 
    echook "\033[0;36m🌏 Ваш домен:\033[0m $WG_HOST"
    local domen_ip
    domen_ip=$(dig +short -4 "$WG_HOST")
    [[ $domen_ip ]] || domen_ip="\033[1;31mнет привязки\033[0m"
    echook "\033[0;36m🆔 Привязан к IP:\033[0m $domen_ip"
  else
    echoerr "Доменное имя отсутствует"
  fi
  echo
  echo " Выберие опцию:"

  if [[ "$is__domain" ]]; then
    echo "  1) 🌐 Сменить доменное имя"
    echo "  2) ❌ Удалить доменное имя"
    echo "  3) 📖 Назад в меню"
    read -rp " Опция: " action

    until [[ "$action" =~ ^[1-3]$ ]]; do
      echoerr "Неверная опция"
      read -rp " Опция: " action
    done

    case "$action" in
      1)
        change_domain
      ;;
      2)
        remove_domain
      ;;
      3)
        select_menu_option
      ;;
    esac
  else
    echo "  1) 🌐 Добавить доменное имя"
    echo "  2) 📖 Назад в меню"
    read -rp " Опция: " action

    until [[ "$action" =~ ^[1-2]$ ]]; do
      echoerr "Неверная опция"
      read -rp " Опция: " action
    done

    case "$action" in
      1)
        add_domain
      ;;
      2)
        select_menu_option
      ;;
    esac
  fi
}

# Функция смены пароля веб интерфейса(ов)
change_password() {
  # вводим новый пароль с заменой в .env
  input_password

  # перезапускаем службу
  systemctl restart wg-easy-breezy > /dev/null 2>&1
  wait_for_containers

  # возвращаемся меню опций
  press_any_side_to_open_menu
}

# Функция вывод последних логов по контейнерам
show_podman_logs() {
  for name in $(podman ps --format '{{.Names}}' | grep "$service_prefix"); do
    echo -e "\n\033[1;34m === Логи $name === \033[0m"
    podman logs --tail 50 "$name"
  done
  press_any_side_to_open_menu "containers"
}

# Функция вывод меню управления контейнерами
select_containers_menu() {
  clear
  show_header
  show_services_list

  local menu
  menu+=" Выберие опцию:\n"
  menu+="  1) 📦 Добавить wg-easy\n"
  menu+="  2) 🧹 Удалить wg-easy\n"
  menu+="  3) 📜 Последние логи\n"
  menu+="  4) 📖 Назад в меню"

  echo -e "$menu"

  read -rp " Опция: " option
  until [[ "$option" =~ ^[1-4]$ ]]; do
    echoerr "Неверная опция"
    read -rp " Опция: " option
  done

  [[ "$option" =~ ^(3|4)$ ]] && clear

  case "$option" in
    1)
      add_new_wg_service
    ;;
    2)
      remove_wg_service
    ;;
    3)
      show_podman_logs
    ;;
    4)
      select_menu_option
    ;;
  esac
}

# Функция вывод статуса systemctl службы
show_systemctl_status() {
  systemctl status wg-easy-breezy --no-pager -l
  press_any_side_to_open_menu
}

# Функция возврата в меню опций по нажатию на любую клавишу
press_any_side_to_open_menu() {
  local type="${1:-main}"

  echomsg "\n ------------------------------------------------"
  read -n1 -r -p " Нажмите любую клавишу, чтобы открыть меню..."

  case "$type" in
    "main")
      select_menu_option
    ;;
    "containers")
      select_containers_menu
    ;;
  esac
}

# Функция выбора опций
select_menu_option() {
  clear
  show_header

  local select_option=" Меню опций:"

  local menu

  if is_all_ok_services; then
    menu+=" 🟢 Служба активна\n"
    menu+="\n$select_option\n"
    menu+="  1) ❌ Остановить\n"
  else
    menu+=" 🔴 Служба не активна\n"
    menu+="\n$select_option\n"
    menu+="  1) 🚀 Запустить\n"
  fi

  menu+="  2) 🌀 Перезапустить\n"
  menu+="  3) 📦 Контейнеры\n"
  menu+="  4) 🌍 Доменное имя\n"
  menu+="  5) 🔑 Сменить пароль\n"
  menu+="  6) 🧿 Статус службы\n"
  menu+="  7) 🪣 Удалить программу\n"
  menu+="  8) 🚪 Выход (Ctrl+C)"

  echo -e "$menu"

  read -rp " Опция: " option
  until [[ "$option" =~ ^[1-8]$ ]]; do
    echoerr "Неверная опция"
    read -rp " Опция: " option
  done

  [[ "$option" =~ ^[1-8]$ ]] && clear

  case "$option" in
    1)
      switch_active_services
    ;;
    2)
      restart_services
    ;;
    3)
      select_containers_menu
    ;;
    4)
      select_domain_option
    ;;
    5)
      change_password
    ;;
    6)
      show_systemctl_status
    ;;
    7)
      remove_services
    ;;
    8)
      exit 0
    ;;
  esac
}

# Функция установки приложения
install() {
  clear
  # проверка поддержки
  check_root
  check_shell
  check_kernel
  check_os
  check_os_ver
  check_container

  # приветсвие
  show_header
  read -n1 -r -p " Нажмите любую клавишу, чтобы начать установку..."

  # удаление предущей установки если была
  # и остались файлы после неудачной
  remove_install

  # установка зависимостей
  install_pkgs

  # выбор режима установки
  select_install_mode

  # создаем необходимы папки и файлы
  mkdir -p "$path_data_dir"
  mkdir -p "$(dirname "$path_script")"
  mkdir -p "$(dirname "$path_env_file")"
  {
    echo "LANG=ru"
    echo "WG_DEFAULT_DNS=1.1.1.1"
    echo "UI_TRAFFIC_STATS=true"
    echo "WG_PERSISTENT_KEEPALIVE=25"
  } > "$path_env_file"

  # считывание вода пользователя
  input_tag
  input_domain
  input_email
  input_ss_link
  input_port
  input_address
  input_password

  # поиск оптимального MTU WireGuard
  find_optimal_wg_mtu

  # создание скриптов iptables правил
  create_iptables_scripts

  # создание конфига докер сервисов
  create_services_config

  # создание sysctl конфига
  create_sysctl_config

  # создание systemd unit службы управления сервисами
  create_systemd_unit

  # запуск сервисов
  start_services
  
  echo
  echo -e "\033[1;32m 🎉 Установка завершена! \033[0m"
  echo -e "\033[0;36m Директория программы: \033[1;32m$path_data_dir \033[0m"
  echo -e "\033[0;36m Веб интерфейс: \033[1;32m$link_ui \033[0m"
  echo

  # перемещам текущий скрипт, добавляем на него права и ссылку
  mv "$(realpath "$0")" "$path_script"
  chmod +x "$path_script"
  ln -s "$path_script" "$path_script_link"

  press_any_side_to_open_menu
}

# Загружаем переменные из .env файла
load_env

if [[ -d "$path_data_dir" ]]; then
  select_menu_option
else
  install
fi